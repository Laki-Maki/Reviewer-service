# PR Reviewer Assignment Service

Сервис автоматического назначения ревьюеров для Pull Request (PR) внутри команд.

## Основные возможности

- **Управление командами и участниками**
- **Создание PR** с автоматическим назначением до 2 ревьюверов из команды автора
- **Merge PR** (идемпотентно) и переназначение ревьюверов
- **Получение списка PR**, где пользователь назначен ревьювером
- **Отслеживание статуса PR** (OPEN / MERGED)
- **HTTP API**, полностью соответствующее OpenAPI-спецификации

## Технологический стек

- **Язык**: Go (Golang)
- **База данных**: PostgreSQL
- **HTTP роутер**: chi
- **Docker & Docker Compose** - контейнеризация сервиса и базы данных

## Архитектура

Проект разделён на слои:

- **Handlers**: обработка HTTP-запросов и валидация данных
- **Services**: бизнес-логика (назначение ревьюверов, merge PR, переназначение)
- **Repositories**: SQL-запросы к PostgreSQL
- **Models**: определение сущностей (User, Team, PullRequest)
- **Database**: подключение к базе и миграции

## Основные сущности

| Сущность | Описание |
|----------|----------|
| **User** | Участник команды с уникальным id, именем и флагом активности |
| **Team** | Группа пользователей с уникальным именем |
| **PullRequest** | PR с id, названием, автором, статусом (OPEN/MERGED) и до 2 назначенными ревьюверами |
| **Reviewer** | Пользователь, назначенный на PR |

## Бизнес-правила

- Автор PR не может быть ревьювером
- Назначаются только активные пользователи
- Merge PR идемпотентен
- Если доступных кандидатов меньше двух — назначается 0 или 1
- Выбор ревьюверов детерминированный по минимальной нагрузке (количество активных PR)

## Логирование и производительность

- **Структурированное логирование** через zap (DEBUG, INFO, WARN, ERROR)
- **Graceful shutdown** 
- **Транзакционные операции** — при ошибках изменения откатываются
- **Индексы** для ускорения поиска пользователей, PR и ревьюверов
- **Равномерное распределение нагрузки** при выборе ревьюверов
- **Агрегация данных в коде, а не в БД** 

Выбор кандидатов делается детерминированно по минимальной нагрузке: сначала считаются назначенные PR каждого кандидата, затем выбираются те с наименьшим количеством текущих назначений. Если несколько кандидатов имеют одинаковую минимальную нагрузку, выбирается тот, кто первым встречается в списке, то есть случайность больше не применяется — алгоритм стал предсказуемым. Таким образом нагрузка распределяется равномерно и стабильно, без рандома.


Все критичные операции сервиса выполняются транзакционно, что гарантирует целостность данных: если что-то идёт не так, изменения откатываются полностью. Для ускорения запросов по пользователям, PR и ревьюерам добавлены индексы, что позволяет мгновенно получать назначенные PR и проверять статусы. Это обеспечивает атомарность операций, защиту от гонок и стабильную производительность даже при росте объёма данных. В итоге сервис остаётся предсказуемым и надёжным при параллельной работе.

## Быстрый старт

Поднять сервис и базу данных:

```bash
docker-compose up --build
```
Сервис будет доступен по адресу: http://localhost:8080

Запустите PowerShell скрипт из файла
```bash
PW_new_скрипт
```

## Проблемы которые я выявил и как я их решал
Было принято решение создать автоматизированные миграции с golang-migrate. Потому, что когда проект растёт, структура БД меняется: добавляются новые таблицы, колонки, индексы, ограничения. Миграции позволяют вносить эти изменения последовательно и контролируемо, чтобы база данных всех разработчиков и продакшена была одинаковой.
```bash
# Создать новую миграцию
make migrate-create NAME=add_users_table

# Запустить миграции вручную (для dev)
make migrate-up

# Откатить последнюю миграцию
make migrate-down

# Запустить всё с Docker
make run

# Остановить сервисы
make docker-down
```

Я заметил, что при возникновении ошибок в коде их трудно отследить, особенно в сложных транзакциях с PR и ревьюверами. Чтобы быстро выявлять проблемы и понимать, что именно происходит на каждом этапе, я внедрил структурированное логирование через zap с уровнями DEBUG, INFO, WARN и ERROR. Логи помогают видеть поток операций, назначение ревьюверов и коммиты транзакций, что значительно упрощает отладку. При этом использование структурированного логирования минимально влияет на производительность, так как данные логируются в формате ключ-значение и могут фильтроваться по уровню.

Проблема с которой я столкнулся: при создании PR или переназначении ревьюверов операции могут выполняться частично — например, PR создаётся, но ревьюверы не назначаются, что нарушает целостность данных.
Решение: обернуть все критичные действия (вставка PR, выбор кандидатов, вставка ревьюверов) в одну транзакцию, чтобы либо всё прошло успешно, либо при ошибке изменения откатывались полностью.
Дополнительно: для случаев, когда кандидатов нет, транзакция позволяет создать PR без ревьюверов, но не оставляет «полуполучившиеся» записи

Проблема: в CreatePR и других операциях с PR логика выбора и назначения ревьюверов частично делается в Go, с множественными отдельными SQL-запросами, что создаёт риск неполной атомарности и лишних round-trip к базе.
Решение: сделать всю транзакцию атомарной и перенести агрегацию/балансировку нагрузки на SQL, чтобы одним запросом выбирать кандидатов с минимальной нагрузкой и назначать до двух ревьюверов. Это уменьшает количество ошибок, повышает производительность и упрощает код

## Что реализовано

- ✅ Подключение к PostgreSQL с миграциями и тестовыми данными
- ✅ Создание PR с автоматическим назначением ревьюверов
- ✅ Merge PR (идемпотентно)
- ✅ Переназначение ревьюверов
- ✅ Получение PR для ревьювера
- ✅ Управление активностью пользователей
- ✅ Полный HTTP API для интеграции
- ✅ Поддержка Docker Compose
